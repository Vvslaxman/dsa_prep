# **Graph Algorithms Study Plan (4 Days)**

---

### **Day 1: Graph Basics, BFS, DFS, and Shortest Path Algorithms**

#### **Topics to Cover:**

1. **Introduction to Graphs**:
   * Definitions: Vertex, Edge, Directed vs Undirected, Weighted vs Unweighted.
   * **Graph Representation**: Adjacency Matrix vs Adjacency List.

2. **Graph Traversals**:
   * **Breadth-First Search (BFS)**: Implementation, use cases (level order traversal, shortest path in unweighted graphs).
   * **Depth-First Search (DFS)**: Implementation, use cases (topological sorting, cycle detection).

3. **Shortest Path Algorithms**:
   * **Dijkstra’s Algorithm**: Shortest path for weighted graphs (positive weights).
   * **Bellman-Ford Algorithm**: Shortest path with negative weights (detect negative cycles).
   * **Floyd-Warshall Algorithm**: All-pairs shortest path (important for smaller graphs).

4. **Basic Problems**:
   * BFS and DFS on unweighted/weighted graphs.
   * Find the shortest path in unweighted graphs (BFS).
   * Detect if a graph is bipartite.

#### **Approximate Time Allocation**:
* **Concepts + Code Explanation**: 3-4 hours
* **Practice Problems**: 3-4 hours

---

### **Day 2: Minimum Spanning Tree (MST), Topological Sort, SCC, and Cycle Detection**

#### **Topics to Cover:**

1. **Minimum Spanning Tree**:
   * **Prim’s Algorithm**: Greedy approach to find MST.
   * **Kruskal’s Algorithm**: Another approach for MST using union-find (disjoint set).

2. **Topological Sorting**:
   * **Topological Sort**: For Directed Acyclic Graphs (DAGs). Use DFS or Kahn’s algorithm.

3. **Cycle Detection**:
   * **DFS Cycle Detection**: Detect cycles in directed and undirected graphs.
   * **Union-Find Algorithm**: Detect cycles in an undirected graph using disjoint-set (important for Kruskal’s algorithm).

4. **Strongly Connected Components (SCC)**:
   * **Kosaraju’s Algorithm**: Finding SCC in directed graphs.
   * **Tarjan’s Algorithm**: Another method for SCC using DFS.

5. **Basic Problems**:
   * Find the MST using Prim’s and Kruskal’s.
   * Topological Sort on a given DAG.
   * Detect cycle in an undirected/directed graph.
   * Find SCCs using Kosaraju/Tarjan.

#### **Approximate Time Allocation**:
* **Concepts + Code Explanation**: 3-4 hours
* **Practice Problems**: 3-4 hours

---

### **Day 3: Advanced Graph Algorithms (Flow, Matching, Dynamic Programming)**

#### **Topics to Cover:**

1. **Max Flow and Min Cut**:
   * **Ford-Fulkerson Algorithm**: Max flow using augmenting paths (Edmonds-Karp for implementation).
   * **Edmonds-Karp**: BFS-based solution for max flow.
   * **Min-Cut Theorem**: Relationship between max flow and min cut.

2. **Graph Coloring**:
   * **Graph Coloring Problem**: Assigning colors to nodes such that no two adjacent nodes share the same color.
   * **Greedy Coloring**: Efficient way to color nodes.

3. **Dynamic Programming on Graphs**:
   * **Longest Path** (for DAGs).
   * **Bellman-Ford** for shortest paths with negative weights (as part of dynamic programming).
   * **Traveling Salesman Problem (TSP)**: Naive solution using DP and backtracking.

4. **Advanced Problems**:
   * Implement Max Flow/Min Cut algorithms.
   * Solve TSP using Dynamic Programming on a graph.
   * Graph coloring problems (e.g., 3-coloring).

#### **Approximate Time Allocation**:
* **Concepts + Code Explanation**: 4-5 hours
* **Practice Problems**: 2-3 hours

---

### **Day 4: Graph Applications, Advanced Topics, and Review**

#### **Topics to Cover:**

1. **Applications of Graphs**:
   * **Shortest Path in a Grid** (e.g., A* Algorithm).
   * **Network Flow Problems** (like bipartite matching).
   * **Route Planning in Maps**: Using BFS/DFS/Dijkstra for finding paths in a graph.

2. **Advanced Topics**:
   * **Eulerian Path and Circuit**: Conditions for the existence of Eulerian paths and circuits.
   * **Hamiltonian Path**: Conditions for Hamiltonian paths (NP-complete problem).
   * **2-Coloring/Planarity**: Checking if a graph is planar and 2-colorable.

3. **Problem Solving Session**:
   * Solve complex graph problems from LeetCode/Codeforces/HackerRank that require multiple algorithms.
   * Practice coding on a whiteboard or in a timed environment to simulate real interview conditions.

4. **Review and Mock Interviews**:
   * Revise all topics.
   * Run through mock interview questions with a timer to simulate real interview conditions.

#### **Approximate Time Allocation**:
* **Concepts + Code Explanation**: 3-4 hours
* **Practice Problems**: 3-4 hours

---
